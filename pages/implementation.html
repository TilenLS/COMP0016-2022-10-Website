<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>COMP0016 2022 Team 10 Website</title>
    <link rel="icon" href="/images/tooth-solid.svg" type="image/x-icon">

    <!-- JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous">
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js" type="text/javascript"></script>

    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/styles.css">

    <!-- Google fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Icons -->
    <script src="https://kit.fontawesome.com/c09be5d4e7.js" crossorigin="anonymous"></script>
</head>

<body>
    <!-- loading-animation -->
    <div class="loader-wrapper">
        <div class='tetrominos'>
            <div class='tetromino box1'></div>
            <div class='tetromino box2'></div>
            <div class='tetromino box3'></div>
            <div class='tetromino box4'></div>
        </div>
    </div>
    <div id="navigation"></div>

    <section id="title-banner">
        <div class="container-fluid">
            <h1>Implementation</h1>
        </div>
    </section>

    <section id="user-interface">
        <div class="container-fluid">
            <h1 class="section-heading section-intro">User Interface</h1>
            <h3 class="section-subheading section-intro">Tools</h3>
            <div class="small-grid features-grid">
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PythonLogo.png" width="150">
                        <p>
                            Main class for loading UI is written in Python.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PySide2Logo.png" width="150">
                        <p>
                            PySide2 widgets and Qt style sheets used to
                            design UI for app.
                        </p>
                    </div>
                </div>
            </div>
            <div class="text-box section-intro">
                <h3 class="section-subheading">Explanation</h3>
                <p>
                    The main class that loads the UI is the MainWindow class seen below.
                    It sets up all the seperate pages. The actual code for these is in
                    their own individual files. The MainWindow class is instanced which loads
                    in the app starting wiht the sign in page.
                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    class MainWindow(QMainWindow, Ui_SignInPage):
        def __init__(self):
            Ui_SignInPage.__init__(self)
            Ui_RegisterPage.__init__(self)
            Ui_HomePage.__init__(self)
            QMainWindow.__init__(self)
            self.ui1 = Ui_SignInPage()
            self.ui2 = Ui_RegisterPage()
            self.ui3 = Ui_HomePage()
            self.lowerFilePath = None
            self.upperFilePath = None
            self.sextantFilePath = None
            self.imageViewer = ImageViewer()
            self.startSignInPage()
            
        def startSignInPage(self):
            ...
        
        def startRegisterPage(self):
            ...
        
        def startHomePage(self):
            ...
                        </code>
                    </pre>
                </div>
                <p>
                    The actual UI code for each page has its own class that takes in
                    the MainWindow class from above. This works as the base window for
                    each page. The UI consits of PySide widgets and layouts. For example,
                    here is how we created a register button with PySide2.
                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    self.register_button = QtWidgets.QPushButton(self.centralwidget)
    self.register_button.setObjectName("register_button")
    self.register_button.setFixedWidth(300)
    self.register_button.setFixedHeight(60)
    self.register_button.setFont(text_font)
    self.register_button.setStyleSheet("QPushButton {\n"
                                    "    border-radius: 5px;\n"
                                    "    background:#8DCBE6;\n"
                                    "    color: #111111;\n"
                                    "}\n"
                                    "\n"
                                    "QPushButton::hover {\n"
                                    "    background:#AEE2FF;\n"
                                    "    color: #111111;\n"
                                    "}")
                        </code>
                    </pre>
                </div>
            </div>
        </div>
    </section>

    <section id="image-processing">
        <div class="container-fluid">
            <h1 class="section-heading section-intro">Image Processing</h1>
            <h3 class="section-subheading section-intro">Tools</h3>
            <div class="small-grid features-grid">
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PythonLogo.png" width="150">
                        <p>
                            Class and functions to integrate image viewing tools into UI.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/Open3DLogo.png" width="150">
                        <p>
                            Processing and displaying STL and PLY files is done with Open3D.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PyPiLogo.png" width="70" height="70">
                        <p>
                            Win32GUI library allows for Open3D to function with PySide2 on Windows.
                        </p>
                    </div>
                </div>
            </div>
            <div class="text-box section-intro">
                <h3 class="section-subheading">Explanation</h3>
                <p>
                    Our app renders 3D STL and PLY files using the Open3D library.
                    We implement these capabilities in a single ImageViewer class.
                    This is mainly done through the Visualizer class which lets us
                    render 3D point cloud models.
                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    def initialise_viewer(self, ui):
        self.mainWindow = ui
        self.widget = ui.widget_3
        self.layout = ui.widget_3_layout
        self.vis = o3d.visualization.Visualizer()
        self.vis.create_window(visible=False)
        if self.meshLower:
            self.vis.add_geometry(self.meshLower)
            self.lowerPresent = True
        if self.meshUpper:
            self.vis.add_geometry(self.meshUpper)
            self.upperPresent = True
        hwnd = win32gui.FindWindowEx(0, 0, None, "Open3D")
        window = QWindow().fromWinId(hwnd)
        windowcontainer = self.createWindowContainer(window, self.widget)
        self.layout.addWidget(windowcontainer, 0)
        self.layout.setContentsMargins(0, 0, 0, 0)
        timer = QTimer(self)
        timer.timeout.connect(self.update_vis)
        timer.start(1)
    
    def update_vis(self):
        ...
    
    def load_mesh(self, lowerFilePath=False, upperFilePath=False):
        ...
    
    def reset_view(self):
        ...
    
    def tr(self, text):
        ...
                        </code>
                    </pre>
                </div>
                <p>
                    We create a window in the background within which we load in
                    the point cloud models if specified. Then we get the window
                    ID using Win32GUI library to merge it into a PySide2 widget
                    and make the window visible again. This then begins the timer
                    that runs the update_vis function that renders the models.
                </p>
            </div>
    </section>

    <section id="data-storage">
        <div class="container-fluid">
            <h1 class="section-heading section-intro">Data Storage</h1>
            <h3 class="section-subheading section-intro">Tools</h3>
            <div class="small-grid features-grid">
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PythonLogo.png" width="150">
                        <p>
                            Back-end logic for data requests processing and storage is in Python.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/SQLiteLogo.png" width="150">
                        <p>
                            SQLite is used to construct and mantain the actual databases.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/AzureLogo.png" width="150">
                        <p>
                            Remote database is stored using an Azure Virtual Machine.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PythonRequestsLogo.png" width="70"
                            height="70">
                        <p>
                            Python Requests library used to make client-side requests to server for data trasnfer.
                        </p>
                    </div>
                </div>
            </div>
            <div class="text-box section-intro">
                <h3 class="section-subheading">Explanation</h3>
                <p>
                    We host a SQLite database stored on an Azure virtual machine. In the database
                    we store the recorded patient data along with their 3D tooth scans and the login
                    credentials of the clinician. All authorised clinicians have access to all the
                    stored patient data.
                </p>
                <p>
                    Both the upstream and downstream system from the client to the server use the
                    Python Requests library to send and recieve data When storing the login
                    credentials we encrypt the password using the Base64 module from the standard
                    python library. Below is an example of storing the login credentials of a newly
                    registered user and recieving a response to relay to the user on the front-end.

                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    def addDentist(self):
        username = self.ui2.username_input.text()
        password1 = self.ui2.password_input.text()
        password2 = self.ui2.confirm_password_input.text()
        encrypted = encrypt(password1)
        payload = {'username': username, 
                'password': password1,
                'confirm_password': password2,
                'encrypted': encrypted.decode("utf-8")}

        url = '...'
        response = requests.post(url, json=payload)
        signup_status = response.json()['result']

        if signup_status == 'success':
            self.startSignInPage()
        elif signup_status == 'fail':
            print("Could not insert dentist data")             
        elif signup_status == 'invalid':
            msg = QMessageBox()
            msg.setWindowTitle("Invalid")
            msg.setIcon(QMessageBox.Warning)
            msg.setText("Password and confirm password are different. Please try again")
            msg.exec_()
                        </code>
                    </pre>
                </div>
                <p>
                    When dealing with the 3D models there is an extra step of pre-processing
                    the data before sending it. We first convert the model into a binary file
                    before sending it to the server. Similary, when making a request for a
                    tooth scan we have to convert from binary back to a point cloud model that
                    can be displayed. This is done with both NumPy to convert to binary and
                    Open3D to convert back into a point cloud model.
                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    def convertToO3dDict(filename):
        # Convert digital data to binary format
        pcd = o3d.io.read_point_cloud(filename)
        points = np.asarray(pcd.points)
        colors = np.asarray(pcd.colors)
        points_list = points.tolist()
        colors_list = colors.tolist()
        data = {'points': points_list, 'colors': colors_list}
        return data
                        </code>
                    </pre>
                </div>
            </div>
        </div>
    </section>


    <section id="tooth-wear-eval">
        <div class="container-fluid">
            <h1 class="section-heading section-intro">Tooth Wear Evaluation</h1>
            <h3 class="section-subheading section-intro">Tools</h3>
            <div class="small-grid features-grid">
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PythonLogo.png" width="150">
                        <p>
                            All the preipheral logic for the key evaluation algorithm written in Python.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/PytorchLogo.png" width="150">
                        <p>
                            Neural network algorithm implemented using PyTorch.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/NumPyLogo.png" width="150">
                        <p>
                            Data pre-processing and other numerical tuning handled with NumPy.
                        </p>
                    </div>
                </div>
                <div class="feature-card">
                    <div class="feature-content">
                        <img class="tool-logo" src="/images/tools-and-dependencies/FlaskLogo.png" width="150">
                        <p>
                            Performs most of the back-end logic. Sending models to be analysed. Recieving
                            results.
                        </p>
                    </div>
                </div>
            </div>
            <div class="text-box section-intro">
                <h3 class="section-subheading">Explanation</h3>
                <p>
                    The network architecture we use is the PointNet deep learning model
                    for 3D classification and segmentation. It is an efficient general
                    purpose algorithm for 3D recognition. Below is the general structure
                    of the network consisting of the classification and segmentation parts.
                </p>
                <img class="img-card" src="/images/PointNet.jpg" width="80%"></img>
                <p>
                    The a pre-trained model that has been trained on 90 tooth models for 50 epochs
                    (with a learning rate of 0.001), using the Adam optimizer. The achieved accuracy
                    is only ~20%. Read more about this on the <a href="/pages/evaluation.html">evaluation page</a>.
                    (Below for now)
                </p>
                <p>
                    Unfortunately, gaining access to more tooth models is difficult due to the emphasis
                    on PLY files which are rare let alone available in public datasets. Therefore,
                    the accuracy is quite low at ~20%. However, the goal of this work is a proof-of-concept
                    pipeline to show that with the given input we can return a result for tooth
                    grading. In the future, optimisation will be very possible as more data will
                    be gathered and the pipeline can be extended beyond simply tooth grading and
                    broader treatment plan suggestions which is the overarching long-term goal of
                    this project. Furthermore, another improvement that should be seriously considered
                    is to implement the automatic re-training of the PointNet model as more data
                    is added to the database. (This will be moved to evaluation page later)
                </p>
                <p>
                    The pre-trained model is mantained on the Azure virtual machine from where
                    any specific model can be accessed. When a user wishes to perform analysis
                    a request is made using Flask to access this file. Then the file is read
                    with the Plyfile library and passed through the pre-trained PointNet model
                    which produces a result. Then this result is retrieved and returned to
                    the front-end to be displayed. Below is the code for such
                    a request.
                </p>
                <div class="code-box">
                    <pre>
                        <code class="language-python">
    @app.route('/predict', methods=['POST'])
    def submit_file():
        """
        Looking for a POST request, if found, save it to the UPLOAD_FOLDER then call the prediction function and return the result back to the client.
        """
        result = {}
        if request.method == 'POST':
            if 'file' not in request.files:
                result =  {'result': 'No file part'}
            file = request.files['file']
            if file == '':
                result =  {'result': 'No file selected for uploading'}
            if file:
                # filename = data['filename']
                # Use werkzeug method to secure filename
                # filename = secure_filename(file)   
                # file.save(os.path.join(app.config['UPLOAD_FOLDER'],filename))
                
                plydata = PlyData.read(file)
                label = get_prediction(plydata)
                # full_filename = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                result =  {'result': 'Your tooth wear grade is: {}'.format(label)}
        return result
                        </code>
                    </pre>
                </div>
            </div>
        </div>
    </section>


    <div id="dynamic-footer"></div>

    <!-- Loading animation, import navigation bar, and set current page to active -->
    <script src="/javascript/prism.js" charset="utf-8"></script>
    <script type="text/javascript">
        $(function () {
            $("#dynamic-footer").load("/pages/html-common/footer.html #import-footer");
            $("#navigation").load("/pages/html-common/navbar.html #import-navbar", function () {
                active = document.getElementById("implementation")
                active.className = "nav-link dropdown-toggle active"
            });
        });
        setTimeout(() => {
            $(".loader-wrapper").fadeOut();
        }, 500);
    </script>
</body>

</html>